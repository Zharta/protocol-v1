{"methods": {"supportsInterface(bytes4)": {"notice": "Query if a contract implements an interface"}, "balanceOf(address)": {"notice": "Count all NFTs assigned to an owner"}, "ownerOf(uint256)": {"notice": "Find the owner of an NFT"}, "getApproved(uint256)": {"notice": "Get the approved address for a single NFT"}, "tokenURI(uint256)": {"notice": "A distinct Uniform Resource Identifier (URI) for a given asset."}, "tokenByIndex(uint256)": {"notice": "Enumerate valid NFTs"}, "tokenOfOwnerByIndex(address,uint256)": {"notice": "Enumerate NFTs assigned to an owner"}, "transferFrom(address,address,uint256)": {"notice": "Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE THEY MAY BE PERMANENTLY LOST"}, "safeTransferFrom(address,address,uint256)": {"notice": "Transfers the ownership of an NFT from one address to another address"}, "approve(address,uint256)": {"notice": "Change or reaffirm the approved address for an NFT"}, "setApprovalForAll(address,bool)": {"notice": "Enable or disable approval for a third party (\"operator\") to manage all of `msg.sender`'s assets"}}}
{"methods": {"supportsInterface(bytes4)": {"params": {"interfaceID": "The interface identifier, as specified in ERC-165"}, "details": "Interface identification is specified in ERC-165. This function uses less than 30,000 gas.", "returns": {"_0": "`true` if the contract implements `interfaceID` and `interfaceID` is not 0xffffffff, `false` otherwise"}}, "balanceOf(address)": {"details": "NFTs assigned to the zero address are considered invalid, and this function throws for queries about the zero address.", "params": {"_owner": "An address for whom to query the balance"}, "returns": {"_0": "The number of NFTs owned by `_owner`, possibly zero"}}, "ownerOf(uint256)": {"details": "NFTs assigned to zero address are considered invalid, and queries about them do throw.", "params": {"_tokenId": "The identifier for an NFT"}, "returns": {"_0": "The address of the owner of the NFT"}}, "getApproved(uint256)": {"details": "Throws if `_tokenId` is not a valid NFT.", "params": {"_tokenId": "The NFT to find the approved address for"}, "returns": {"_0": "The approved address for this NFT, or the zero address if there is none"}}, "tokenURI(uint256)": {"details": "Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC 3986. The URI may point to a JSON file that conforms to the \"ERC721 Metadata JSON Schema\"."}, "tokenByIndex(uint256)": {"details": "Throws if `_index` >= `totalSupply()`.", "params": {"_index": "A counter less than `totalSupply()`"}, "returns": {"_0": "The token identifier for the `_index`th NFT, (sort order not specified)"}}, "tokenOfOwnerByIndex(address,uint256)": {"details": "Throws if `_index` >= `balanceOf(_owner)` or if `_owner` is the zero address, representing invalid NFTs.", "params": {"_owner": "An address where we are interested in NFTs owned by them", "_index": "A counter less than `balanceOf(_owner)`"}, "returns": {"_0": "The token identifier for the `_index`th NFT assigned to `_owner`, (sort order not specified)"}}, "transferFrom(address,address,uint256)": {"details": "Throws unless `msg.sender` is the current owner, an authorized operator, or the approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero address. Throws if `_tokenId` is not a valid NFT.", "params": {"_from": "The current owner of the NFT", "_to": "The new owner", "_tokenId": "The NFT to transfer"}}, "safeTransferFrom(address,address,uint256)": {"details": "Throws unless `msg.sender` is the current owner, an authorized operator, or the approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero address. Throws if `_tokenId` is not a valid NFT. When transfer is complete, this function checks if `_to` is a smart contract (code size > 0). If so, it calls `onERC721Received` on `_to` and throws if the return value is not `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.", "params": {"_from": "The current owner of the NFT", "_to": "The new owner", "_tokenId": "The NFT to transfer", "data": "Optional additional data with no specified format, sent in call to `_to`"}}, "safeTransferFrom(address,address,uint256,bytes)": {"details": "Throws unless `msg.sender` is the current owner, an authorized operator, or the approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero address. Throws if `_tokenId` is not a valid NFT. When transfer is complete, this function checks if `_to` is a smart contract (code size > 0). If so, it calls `onERC721Received` on `_to` and throws if the return value is not `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.", "params": {"_from": "The current owner of the NFT", "_to": "The new owner", "_tokenId": "The NFT to transfer", "data": "Optional additional data with no specified format, sent in call to `_to`"}}, "approve(address,uint256)": {"details": "The zero address indicates there is no approved address. Throws unless `msg.sender` is the current NFT owner, or an authorized operator of the current owner.", "params": {"_approved": "The new approved NFT controller", "_tokenId": "The NFT to approve"}}, "setApprovalForAll(address,bool)": {"details": "Emits the ApprovalForAll event. The contract MUST allow multiple operators per owner.", "params": {"_operator": "Address to add to the set of authorized operators", "_approved": "True if the operator is approved, false to revoke approval"}}}}
